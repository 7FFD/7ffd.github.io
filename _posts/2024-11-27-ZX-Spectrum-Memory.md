---
layout: post
title:   "Організація пам'яті в ZX Spectrum"
categories:
    - ZX Spectrum
    - Memory
excerpt_separator: <!--more-->
---
Коли ми говоримо про ZX Spectrum оригінальної зборки, в назвах перших моделей зустрічається наступне: 16к, 48к або 128к.
Можливо ви вже здогадалися, що йдеться про об'єм пам'яті і в цьому конкретному випадку, йдеться про оперативну пам'ять. Тобто, версія 16к - мала 16 кілобайтів RAM, 48k - відповідно 48 кілобайтів RAM і тд.

    Мапа пам'яті
    ----------------------------------------------
    Версія  16к                         48к

                                0xFFFF  +--------+
                                        |        |
                                        |        |
                                        |        |
                                        |        |
                                        |        |
                                        |        |
                                        |        |
                                        | блок 1 |
    0x8000  +--------+          0x8000  +--------+
            |        |                  |        |
            | блок 0 |                  | блок 0 |
            |--------|                  |--------|
            | екран  |                  | екран  |
    0x4000  +--------+          0x4000  +--------+
            |  ROM   |                  |  ROM   |
            |        |                  |        |
            |        |                  |        |
            |        |                  |        |
    0x0000  +--------+          0x0000  +--------+

<!--more-->

Як можна побачити, мапа пам'яті у 16k версії починаєтся з адреса 0x0000 і закінчується 0x8000 (останній доступний байт 0x7FFF). І тут щось виглядає явно не так... Дійсно, я не просто так уточнював про RAM, тому що в обох мапах перші 16 кілобайтів зайняті під ROM. В ті часи чіпи ROM або Read Only Memory використовувалися для постійного зберігання мікропрограмного забезпечення, це така собі мікро операційна система, яка надавала користувачу можливість комунікації з комп'ютером після включення. В сучасних комп'ютерах за цю функцію відповідає BIOS. У ZX Spectrum такою “ОС“ був діалект Basic'a. 

Ще можна зустріти назву СОС (SOS), від "Стандартна Операційна Система" (Standard Operation System) - це все той самий Бейсік.

Тому в перших 16 кілобайтах, до адреса 0x4000, "живе" Бейсік.

Далі, з адреса 0x4000, починається область відеопам'яті. Так, вона у спеку знаходитьсяв одному просторі зі всією пам'яттю. Відеопам'ять займає 6912 байтів, що в коомбінації зі специфічною архітектурою, дозволяє відображати зображення з роздільною здатністю 256х192 піксела, 16 кольорів. Відеопам'яті спека і її особливостям буде присвячений окремий пост, тому, поки що не буду зупинятися на подробицях.

І, нарешті, з адреса 0x5B00 починається пам'ять загального користування або користувацька. Для версії 16к це не так і багато: 0x8000-0x5B00=0x2500, в десятковому вигляді це 9472 байти, тобто трохи більше 9 кілобайтів, не багато...

Чекайте, у нас же ще є Бейсік, який після старта забирає частину з цих крихт під буфер принтера і системні змінні.
Фактично, ще зменшуюючи об'єм на 0x1CB або 459 байтів.
По факту, під текст програми байсіка, стек і пам'ять під змінні бейсіка залишалося трохи менше 9Кб.

Тому, достатньо швидко на ринку з'явилася модель 48к, яка мала "на борту" додаткові 32Кб пам'яті, що на той момент, було вже достатньо для програм на бейсіку і більш ніж достатньо для програм написаних на асемблері.

Ще один цікавий момент, ці, так звані "верхні", 32Кб відносилися до "швидкої" пам'яті. Справа у тому, що відеопам'ять у блоці 0, використовується схемою виводу зображення і під час її роботи процесор просто зупиняється, при спробі запису або читання з цього блоку. Тому для прискорення роботи програм, правильніше було використовувати цю "швидку" пам'ять.

Насправді, 32Кб+9Кб = 41Кб, на ті часи, був цілком достатній об'єм - вистачить подивитися на ту кількість ігор і програм, які були написані... Це такі шедеври, як Elite, Sabateur I-II, Commando та інші.

## Версія 128к

Нарощування пам'яті на 32Кб далося порівнянно просто - додавнням чіпів і простою схемою адресації. Чому ж тоді одразу не розширили пам'ять ще більше?
Все просто, процесор Z80 може адресувати тільки 65536 байтів, оскільки має 16 ліній адреса.
Тому перед інженерами встала задача - як розширити пам'ять і при тому залишитися в тому ж адресному просторі процесора?

Рішення, насправді, було не нове і повсякчас використовувалося в ті часи - це сторінкова адресація або paging.
Ідея підходу полягає в тому, що в той сами адресний простір можна "підставити" інший шматок фізичної пам'яті: у схемі додавали механізм, який програмно дозволяв переключати частини фізичної пам'яті і достосовувати їх до конкретного адресного простору.

Ось як це було реалізовано у 128к версії:

    0xFFFF  +--------+--------+--------+--------+--------+--------+--------+--------+
            | Банк 0 | Банк 1 | Банк 2 | Банк 3 | Банк 4 | Банк 5 | Банк 6 | Банк 7 |
            |        |        |(теж в  |        |        |(теж   в|        |        |
            |        |        | 0x8000)|        |        | 0x4000)|        |        |
    0xC000  |        |        |        |        |        | екран 0|        | екран 1|
    Блок 3  +--------+--------+--------+--------+--------+--------+--------+--------+
            | Банк 2 |        Будь який банк може бути переключений
            |        |
            |        |
    0x8000  |        |
    Блок 2  +--------+
            | Банк 5 |
            |        |
            |        |
    0x4000  | екран  |
    Блок 1  +--------+--------+
            | ROM 0  | ROM 1  |
            |        |        |
            |        |        |
    0x0000  |        |        |
    Блок 0  +--------+--------+

По перше, адресний простір процесора був поділений на чотири 16кБ блоки: 
 - Блок 0: 0x0000-0x03FFF
 - Блок 1: 0x4000-0x07FFF
 - Блок 2: 0x8000-0x0BFFF
 - Блок 3: 0xC000-0xFFFF

Додаткову фізичну пам'ять було вирішено відображати в адерсах 0xC000-0xFFFF, тобто останні 16кБ.

Щоб керувати, який банк буде зараз підключений до блоку 3, достатньо записати в порт 0x7FFD відповідне значення. Мапа бітів виглядає наступним чином:

    +-------+-------+-------+-------+-------+-------+-------+-------+
    |   7   |   6   |   5   |   4   |   3   |   2   |   1   |   0   |
    +-------+-------+-------+-------+-------+-------+-------+-------+
    |   -   |   -   | ВИМК  |  ROM  | ЕКРАН |     RAM БАНК 0 - 7    |
    +-------+-------+-------+-------+-------+-------+-------+-------+

- Біти 0-2: номер банка, який буде яктивний в блоці 3
- Біт 3: 0= банк 5 буде виводитися на екран, 1= банк 7
- Біт 4: відповідно 0= 128EDITOR ROM, 1= BASIC48 ROM
- Біт 5: при запису 1, блокується подальша робота порта до наступного скидання
- Біти 6-7: не задіяні

 > Біт 5 відповідає за режим сумісності з 48к, при запису 1, порт 0x7FFD деактивувався і не сприймав запис до наступного скидання

Оскільки практично всі 16кБ ROM були зайняті під код бейсіка, для розширення можливостей, було вирішено додати ще один 16кБ ROM.
Відповідно в банку ROM0 було розміщено розширення 128EDITOR, а в банку ROM1 залишався BASIC48, хоча і трохи модифікований.

## 256кБ+

Подальше розширення вже відбувалося силами комьюніті ZX Spectrum сумісних машин. Різні клони на просторах СНД мали свої схеми розширення пам'яті, але прижилася, і стала де-факто стандартом, схема **Пентагона**[^1].
Для розширення до 256-512кБ були задіяні біти 6-7 відповідно.

Щоб додати 1МБ, був задіяний біт 5, і щоб залишити сумісність з 128к, порт 0xEFF7 використовувався, як конфігураційний для Пентагона. За його допомогою, можна включити режим сумісності з 128к, тоді біт 5 буде працювати так само, як у 128к.

 > Свою назву Пентагон отримав завдяки вигляду друкованої плати, з обрізаним одним з кутів прямокутника.

 Нижче приведена мапа пам'яті для Пентагон 512к:

    0xFFFF  +--------+--------+--------+--------+--------+--------+--------+--------+
            |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |
    512Kb   |  0xC0  |  0xC1  |  0xC2  |  0xC3  |  0xC4  |  0xC5  |  0xC6  |  0xC7  |
            |        |        |        |        |        |        |        |        |
            |        |        |        |        |        |        |        |        |
            +--------+--------+--------+--------+--------+--------+--------+--------+
            |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |
    348Kb   |  0x80  |  0x81  |  0x82  |  0x83  |  0x84  |  0x85  |  0x86  |  0x87  |
            |        |        |        |        |        |        |        |        |
            |        |        |        |        |        |        |        |        |
            +--------+--------+--------+--------+--------+--------+--------+--------+
            |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |
    256Kb   |  0x40  |  0x41  |  0x42  |  0x43  |  0x44  |  0x45  |  0x46  |  0x47  |
            |        |        |        |        |        |        |        |        |
            |        |        |        |        |        |        |        |        |
            +--------+--------+--------+--------+--------+--------+--------+--------+
            |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |  Банк  |
    128Kb   |  0x00  |  0x01  |  0x02  |  0x03  |  0x04  |  0x05  |  0x06  |  0x07  |
            |        |        |        |        |        | екран 0|        | екран 1|
    0xС000  |        |        | Блок 2 |        |        | Блок 1 |        |        |
    Блок 3  +--------+--------+--------+--------+--------+--------+--------+--------+
            | Банк 2 |        Будь який банк може бути переключений
            |        |
            |        |
    0x8000  |        |
    Блок 2  +--------+
            | Банк 5 |
            |        |
            |        |
    0x4000  | екран  |
    Блок 1  +--------+--------+
            | ROM 0  | ROM 1  |
            |        |        |
            |        |        |
    0x0000  |        |        |
    Блок 0  +--------+--------+

## Проблеми сторінкової адресації

Хіба проблема з об'ємом вирішина, але це додало низку обмежень на користання Блоком 3.

Уявіть, що ви загрузили в сторінку 0x41 код, а в сторінку 0x42 дані і плануєте цим кодом обробляти дані...
Тепер перемикаєте на сторінку 0x41 і робите виклик, скажімо, функції обчислення. Процесор читає код з Блока 3, де зараз вибрана сторінка 0x41. Тепер функція перемикає Блок 3 на сторінку 0x42, щоб прочитати дані... і все, далі зависання і нічого не працює.

Проблема полягає в тому, що після перемикання на сторінку 0x42, процесор вичитує наступну інструкцію вже з сторінки 0x42, де лежать наші дані, а не код. Справа у тому, що процесор не знає, як перемикати сторінки і вважає, що пам'ять одна і та ж. Вихід з такої ситуації є - треба щоб процесор, під час читання з сторінки 0x42, виконував код в іншому Блоку, наприклад в Блоку 2. Для цього необхідно розмістити код функції (або її частину) читання/запису даних в Блоку 2 і в момент, коли будуть читатися дані, процесор буде виконувати код в "постійному" Блоці.

Для кращого розуміння, приведу код на асемблері, який читає і записує дані:

                ORG #8000           ; код в постійному Блоці (2)
                ; функція читання
                ; HL: адрес даних
                ;  A: прочитані дані
    RDATA       LD BC, 0x7FFD       ; порт переключення сторінки
                LD  E, 0x42         ; сторінка в Блоку 3
                OUT (C), E          ; переключення
                ; з цього моменту в Блоку 3 активна сторінка 0x42
                ; і можна читати дані
                LD A,(HL)
                LD E, 0x41          ; сторінка з кодом
                OUT (C), E          ; переключаємо
                ; тепер в Блоку 3 знаходиться сторінка 0x41 з кодом
                RET                 ; можемо повертатися
                ;
                ; функція запису
                ; HL: адрес даних
                ;  A: дані для запису
    WDATA       LD BC, 0x7FFD       ; порт переключення сторінки
                LD  E, 0x42         ; сторінка в Блоку 3
                OUT (C), E          ; переключення
                ; з цього моменту в Блоку 3 активна сторінка 0x42
                ; і можна записувати дані
                LD (HL), A
                LD E, 0x41          ; сторінка з кодом
                OUT (C), E          ; переключаємо
                ; тепер в Блоку 3 знаходиться сторінка 0x41 з кодом
                RET                 ; можемо повертатися
                ;...
                ORG #C000           ; код в Блоці 3, де відбувається переключення
                ; основна програма в Блоці 3
    MAIN        LD HL, #C000        ; адрес даних на сторінці 0x42
                CALL RDATA          ; читаємо дані
                INC A               ; змінюємо дані
                CALL WDATA          ; записуємо дані
                RET

Як бачете, сторінковий підхід ускладнює код і робить його місцями зовсім не очевидним.

Нижче приклад коду, який не використовує перемикання:

                ORG #8000           ; код в Блоці 2
                ; основна програма в Блоці 2
    MAIN        LD HL, #C000        ; адрес даних 
                LD A, (HL)          ; читаємо дані
                INC A               ; змінюємо дані
                LD (HL), A          ; записуємо дані
                RET

Погодьтеся, код виглядає набагато простіше... Але ж не має додаткової пам'яті.

Підхід з викликом коду з "постійного" Блоку теж не є ідеальним. Справа у тому, що з постійних у нас є тільки два блоки: 1 і 2. І з цим треба рахуватися.

Ще одна проблема полягає в тому, що Блок 3 НЕ МОЖНА використовувати для зберігання стеку програм. Причина все та ж сама - при переключенні, процесор буде читати дані стека не з тої сторінки, що скоріш за все призведе до зависання і непердбачуваної поведінки програми.

Існує багато підходів, як обійти проблеми сторінкової адресації. Найбільш складним і професійним є - розміщення функції перемикання в стеку, під час виконання переключення. Цей спосіб затратний по часу виконання, але є універсальним і не потребує розміщення коду в "постійному" Блоці. В наступних статтях я розповім про середу розробки ALASM і наведу приклади кода, який дає можливість перемикати сторінки за посередництвом стеку.

І на останок, кілька фото з розширенням пам'яті Harlequin 128k до 512Kb.

[![ZX Spectrum Memory, Схема розширення пам'яті до 512Кб][1]][1]
   
   [1]: /content/2024-11-27-ZX-Spectrum-Memory/01-zx-spectrum-memory-map.png "ZX Spectrum Memory, Схема розширення пам'яті до 512Кб"

Схема Harlequin 128k розширюється додатковими тригерами для зберігання бітів, відповідальних за адресацію 256Кб і 512Кб сторінок.

Щоб не різати і паяти оригінальну плату, вирішив зробити "другим поверхом". На місця мікросхем, з яких треба брати сигнали, встановив перехідні цангові панелькі і до їх виводів підпаяв необхідні проводки. Для мікросхем, у яких треба підміняти сигнали, використав плати другого поверху. Наприклад, не задіяні в оригінальній схемі виводи мікросхем пам'яті підключені або до +5в або до землі, тому їх треба було від'єднати і під'єднати до відповідних виходів тригерів.

Ось так виглядає "другий поверх" на платі:

[![ZX Spectrum Memory, "Другий поверх"][2]][2]
   
   [2]: /content/2024-11-27-ZX-Spectrum-Memory/02-zx-spectrum-memory-map.png "ZX Spectrum Memory, "Другий поверх""

Така реалізація дає можливість будь коли повернутися до оригінального стану плати просто знявши цей "другий поверх".

І, нарешті, перевірка чи додалося пам'яті. ALASM відрапортував, що доступно 512Кб. Значить можна починати користуватися розширеною пам'яттю.

[![ZX Spectrum Memory, ALASM задетектив 512Кб][3]][3]
   
   [3]: /content/2024-11-27-ZX-Spectrum-Memory/03-zx-spectrum-memory-map.png "ZX Spectrum Memory, ALASM задетектив 512Кб"

## Виноски

[^1]: Пентагон \(Pentagon\), подальший розвиток ZX Spectrum: [https://en.wikipedia.org/wiki/Pentagon_\(computer\)](https://en.wikipedia.org/wiki/Pentagon_(computer))
